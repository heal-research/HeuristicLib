using HEAL.HeuristicLib.Operators;
using HEAL.HeuristicLib.Random;

namespace HEAL.HeuristicLib.SearchSpaces;

public record class RealVectorSearchSpace : SearchSpace<RealVector>, ISubspaceComparable<RealVectorSearchSpace> {
  public int Length { get; }
  public RealVector Minimum { get; }
  public RealVector Maximum { get; }
  //public IRepairer<RealVector> OutOfBoundsRepairer { get; }

  public RealVectorSearchSpace(int length, RealVector minimum, RealVector maximum/*, OutOfBoundsStrategy outOfBoundsRepairer = OutOfBoundsStrategy.Clamp*/) {
    if (!RealVector.AreCompatible(length, minimum, maximum)) throw new ArgumentException("Minimum and Maximum vector must be of length 1 or match the searchSpace length");
    Length = length;
    Minimum = minimum;
    Maximum = maximum;
  //  OutOfBounds = outOfBounds;
  }
  
  public override bool Contains(RealVector genotype) {
    return genotype.Count == Length
           && (genotype >= Minimum).All()
           && (genotype <= Maximum).All();
  }
  
  public bool IsSubspaceOf(RealVectorSearchSpace other) {
    return other.Length == Length
           && (other.Minimum >= Minimum).All()
           && (other.Maximum <= Maximum).All();
  }
  


  // This is generated by the record anyway
  // #pragma warning disable S125
  // public override bool Equals(ISearchSpace<RealVector>? other) {
  //   if (other is null) return false;
  //   if (ReferenceEquals(this, other)) return true;
  //   if (other is RealVectorSearchSpace otherRealVectorSearchSpace) {
  //     return Length == otherRealVectorSearchSpace.Length 
  //            && Minimum == otherRealVectorSearchSpace.Minimum
  //            && Maximum == otherRealVectorSearchSpace.Maximum;
  //   }
  //   return false;
  // }
  // #pragma warning restore S125
}

// public enum OutOfBoundsStrategy {
//   Clamp,
//   Reflect,
//   Randomize,
//   Exception
// }
//
// public interface IRepairer<TGenotype> {
//   TGenotype Repair(TGenotype genotype);
// }

// public abstract class RealVectorRepairer : IRepairer<RealVector> {
//   public static ClampRepairer Clamp(RealVectorSearchSpace parameter) => new ClampRepairer(parameter);
//   
//   protected RealVectorSearchSpace Parameter { get; }
//   protected RealVectorRepairer(RealVectorSearchSpace parameter) {
//     Parameter = parameter;
//   }
//   public abstract RealVector Repair(RealVector genotype);
// }
// public class ClampRepairer : RealVectorRepairer {
//   public ClampRepairer(RealVectorSearchSpace parameter) : base(parameter) { }
//   public override RealVector Repair(RealVector genotype) => RealVector.Clamp(genotype, Parameter.Minimum, Parameter.Maximum);
// }
//
// public class RealVectorSearchSpace<TPhenotype>
//   : SearchSpace<RealVector, TPhenotype>,
//     ICreatorProvidingSearchSpace<RealVector, RealVectorSearchSpace>, ICrossoverProvidingSearchSpace<RealVector, RealVectorSearchSpace>, IMutatorProvidingSearchSpace<RealVector, RealVectorSearchSpace> {
//   
//   public required ICreator<RealVector, RealVectorSearchSpace> Creator { get; init; }
//   public required ICrossover<RealVector, RealVectorSearchSpace> Crossover { get; init; }
//   public required IMutator<RealVector, RealVectorSearchSpace> Mutator { get; init; }
//   
//   public RealVectorSearchSpace(IDecoder<RealVector, TPhenotype> decoder) 
//     : base(decoder) { }
// }

// public class RealVectorSearchSpace : RealVectorSearchSpace<RealVector> { // Genotype = Phenotype
//   public RealVectorSearchSpace(RealVectorSearchSpace parameter) : base(parameter, Operators.Decoder.Identity<RealVector>()) { }
// }




public record class AlphaBetaBlendCrossover : Crossover<RealVector, RealVectorSearchSpace> {
  public double Alpha { get; }
  public double Beta { get; }
  
  public AlphaBetaBlendCrossover(double alpha = 0.7, double beta = 0.3) {
    Alpha = alpha;
    Beta = beta;
  }

  public override AlphaBetaBlendCrossoverInstance CreateInstance() => new AlphaBetaBlendCrossoverInstance(this);
}

public class AlphaBetaBlendCrossoverInstance : CrossoverInstance<RealVector, RealVectorSearchSpace, AlphaBetaBlendCrossover> {
  public AlphaBetaBlendCrossoverInstance(AlphaBetaBlendCrossover parameters) : base(parameters) { }
  public override RealVector Cross(RealVector parent1, RealVector parent2, RealVectorSearchSpace searchSpace, IRandomNumberGenerator random) {
    return Parameters.Alpha * parent1 + Parameters.Beta * parent2;
  }
}


public record class GaussianMutator : Mutator<RealVector, RealVectorSearchSpace> {
  public double MutationRate { get; }
  public double MutationStrength { get; }

  public GaussianMutator(double mutationRate, double mutationStrength) {
    MutationRate = mutationRate;
    MutationStrength = mutationStrength;
  }

  public override GaussianMutatorInstance CreateInstance() => new GaussianMutatorInstance(this);
}

public class GaussianMutatorInstance : MutatorInstance<RealVector, RealVectorSearchSpace, GaussianMutator> {
  public GaussianMutatorInstance(GaussianMutator parameters) : base(parameters) { }
  public override RealVector Mutate(RealVector solution, RealVectorSearchSpace searchSpace, IRandomNumberGenerator random) {
    double[] newElements = solution.ToArray();
    for (int i = 0; i < newElements.Length; i++) {
      if (random.Random() < Parameters.MutationRate) {
        newElements[i] += Parameters.MutationStrength * (random.Random() - 0.5);
      }
    }
    return RealVector.Clamp(new RealVector(newElements), searchSpace.Minimum, searchSpace.Maximum);
  }
}


public record class SinglePointCrossover : Crossover<RealVector, RealVectorSearchSpace> {
  public override SinglePointCrossoverInstance CreateInstance() => new SinglePointCrossoverInstance(this);
}

public class SinglePointCrossoverInstance : CrossoverInstance<RealVector, RealVectorSearchSpace, SinglePointCrossover> {
  public SinglePointCrossoverInstance(SinglePointCrossover parameters) : base(parameters) { }
  public override RealVector Cross(RealVector parent1, RealVector parent2, RealVectorSearchSpace searchSpace, IRandomNumberGenerator random) {
    int crossoverPoint = random.Integer(1, parent1.Count);
    double[] offspringValues = new double[parent1.Count];
    for (int i = 0; i < crossoverPoint; i++) {
      offspringValues[i] = parent1[i];
    }
    for (int i = crossoverPoint; i < parent2.Count; i++) {
      offspringValues[i] = parent2[i];
    }
    return RealVector.Clamp(new RealVector(offspringValues), searchSpace.Minimum, searchSpace.Maximum);
  }
}


public record class NormalDistributedCreator : Creator<RealVector, RealVectorSearchSpace> {
  public RealVector Means { get; }
  public RealVector Sigmas { get; }

  //public const double DefaultMeans = 0.0;
  //public const double DefaultSigmas = 1.0;

  public NormalDistributedCreator(RealVector means, RealVector sigmas) {
    //if (!RealVector.AreCompatible(searchSpace.Length, means, sigmas, searchSpace.Minimum, searchSpace.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    Means = means;
    Sigmas = sigmas;
  }
  
  public override NormalDistributedCreatorInstance CreateInstance() => new NormalDistributedCreatorInstance(this);
}

public class NormalDistributedCreatorInstance : CreatorInstance<RealVector, RealVectorSearchSpace, NormalDistributedCreator> {
  public NormalDistributedCreatorInstance(NormalDistributedCreator parameters) : base(parameters) { }
  public override RealVector Create(RealVectorSearchSpace searchSpace, IRandomNumberGenerator random) {
    if (!RealVector.AreCompatible(searchSpace.Length, Parameters.Means, Parameters.Sigmas, searchSpace.Minimum, searchSpace.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    RealVector value = RealVector.CreateNormal(searchSpace.Length, Parameters.Means, Parameters.Sigmas, random);
    // Clamp value to min/max bounds
    value = RealVector.Clamp(value, searchSpace.Minimum, searchSpace.Maximum);
    return value;
  }
}


public record class UniformDistributedCreator : Creator<RealVector, RealVectorSearchSpace> {
  public RealVector? Minimum { get; }
  public RealVector? Maximum { get; }

  public UniformDistributedCreator(RealVector? minimum = null, RealVector? maximum = null) {
    Minimum = minimum;
    Maximum = maximum;
  }
  
  public override UniformDistributedCreatorInstance CreateInstance() => new UniformDistributedCreatorInstance(this);
}

public class UniformDistributedCreatorInstance : CreatorInstance<RealVector, RealVectorSearchSpace, UniformDistributedCreator> {
  public UniformDistributedCreatorInstance(UniformDistributedCreator parameters) : base(parameters) { }
  public override RealVector Create(RealVectorSearchSpace searchSpace, IRandomNumberGenerator random) {
    if (Parameters.Minimum is not null && (Parameters.Minimum < searchSpace.Minimum).Any()) throw new ArgumentException("Minimum values must be greater or equal to searchSpace minimum values");
    if (Parameters.Maximum is not null && (Parameters.Maximum > searchSpace.Maximum).Any()) throw new ArgumentException("Maximum values must be less or equal to searchSpace maximum values");
    if (!RealVector.AreCompatible(searchSpace.Length, Parameters.Minimum ?? searchSpace.Minimum, Parameters.Maximum ?? searchSpace.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    return RealVector.CreateUniform(searchSpace.Length, Parameters.Minimum ?? searchSpace.Minimum, Parameters.Maximum ?? searchSpace.Maximum, random);
  }
}

// // ToDo: move to different file
// public static class GeneticAlgorithmBuilderRealVectorSearchSpaceExtensions {
//   // For type inference
//   public static GeneticAlgorithmBuilder<RealVector, RealVectorSearchSpace> UsingSearchSpace(this GeneticAlgorithmBuilder<RealVector> builder, RealVectorSearchSpace searchSpace) {
//     return builder.UsingSearchSpace<RealVector, RealVectorSearchSpace, RealVectorSearchSpace>(searchSpace);
//   }
// }

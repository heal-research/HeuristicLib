using System.Diagnostics.CodeAnalysis;
using HEAL.HeuristicLib.Algorithms.GeneticAlgorithm;

namespace HEAL.HeuristicLib.Encodings;

using System.Collections;
using Algorithms;
using Operators;

public record class RealVectorEncodingParameter : EncodingParameterBase<RealVector> {
  public int Length { get; }
  public RealVector Minimum { get; }
  public RealVector Maximum { get; }

  public RealVectorEncodingParameter(int length, RealVector minimum, RealVector maximum) {
    if (!RealVector.AreCompatible(length, minimum, maximum)) throw new ArgumentException("Minimum and Maximum vector must be of length 1 or match the encoding length");
    Length = length;
    Minimum = minimum;
    Maximum = maximum;
  }
  
  public override bool IsValidGenotype(RealVector genotype) {
    return genotype.Count == Length
           && (genotype >= Minimum).All()
           && (genotype <= Maximum).All();
  }

  // This is generated by the record anyway
  // #pragma warning disable S125
  // public override bool Equals(IEncoding<RealVector>? other) {
  //   if (other is null) return false;
  //   if (ReferenceEquals(this, other)) return true;
  //   if (other is RealVectorEncoding otherRealVectorEncoding) {
  //     return Length == otherRealVectorEncoding.Length 
  //            && Minimum == otherRealVectorEncoding.Minimum
  //            && Maximum == otherRealVectorEncoding.Maximum;
  //   }
  //   return false;
  // }
  // #pragma warning restore S125
}

public class AlphaBetaBlendCrossover : CrossoverBase<RealVector> {
  //public RealVectorEncoding Encoding { get; }
  public double Alpha { get; }
  public double Beta { get; }
  
  // <param name="alpha">Some Description (default: 0.7 if null)</param>
  // <param name="beta">Some Description (default: 0.3 if null)</param>
  public AlphaBetaBlendCrossover(/*RealVectorEncoding encoding,*/ double? alpha = null, double? beta = null) {
    //Encoding = encoding;
    Alpha = alpha ?? 0.7;
    Beta = beta ?? 0.3;
  }

  public override RealVector Cross(RealVector parent1, RealVector parent2) {
    return Alpha * parent1 + Beta * parent2;
  }

  public class Factory : IEncodingParameterDependentOperatorFactory<AlphaBetaBlendCrossover, RealVectorEncodingParameter> {
    private readonly double? alpha;
    private readonly double? beta;
    
    public Factory(double? alpha, double? beta) {
      this.alpha = alpha;
      this.beta = beta;
    }
    
    public AlphaBetaBlendCrossover Create(RealVectorEncodingParameter parameter, IRandomSource randomSource) {
      return new AlphaBetaBlendCrossover(alpha, beta); 
    }
  }
}


[SuppressMessage("Blocker Code Smell", "S3877:Exceptions should not be thrown from unexpected methods")]
public class RealVector : IReadOnlyList<double> {
  private readonly double[] elements;

  public RealVector(IEnumerable<double> elements) {
    this.elements = elements.ToArray();
  }

  public RealVector(double value) {
    elements = new[] { value };
  }

  public static implicit operator RealVector(double value) => new RealVector(value);

  public double this[int index] => elements[index];

  public double this[Index index] => elements[index];

  public IEnumerator<double> GetEnumerator() => ((IEnumerable<double>)elements).GetEnumerator();

  IEnumerator IEnumerable.GetEnumerator() => elements.GetEnumerator();

  public static RealVector Add(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x + a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x + b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] + b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Subtract(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x - a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x - b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] - b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Multiply(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x * a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x * b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] * b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Divide(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x / a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x / b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] / b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector operator +(RealVector a, RealVector b) => Add(a, b);
  public static RealVector operator -(RealVector a, RealVector b) => Subtract(a, b);
  public static RealVector operator *(RealVector a, RealVector b) => Multiply(a, b);
  public static RealVector operator /(RealVector a, RealVector b) => Divide(a, b);

  public int Count => elements.Length;

  public bool Contains(double value) => elements.Contains(value);

  
  public static bool AreCompatible(RealVector a, RealVector b) {
    return a.Count == b.Count || a.Count == 1 || b.Count == 1;
  }
  public static bool AreCompatible(RealVector vector, params IEnumerable<RealVector> others) {
    return others.All(v => AreCompatible(vector, v));
  }
  public static bool AreCompatible(int length, params IEnumerable<RealVector> vectors) {
    return vectors.All(v => v.Count == length || v.Count == 1);
  }
  
  public static int BroadcastLength(RealVector a, RealVector b) {
    return Math.Max(a.Count, b.Count);
  }
  public static int BroadcastLength(RealVector vector, IEnumerable<RealVector> others) {
    if (!AreCompatible(vector, others)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    return others.Max(v => v.Count);
  }
  
  public static RealVector CreateNormal(int length, RealVector mean, RealVector std, IRandomNumberGenerator random) {
    if (!AreCompatible(length, mean, std)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    
    // Box-Muller transform to generate normal distributed random values
    RealVector u1, u2;
    do {
      u1 = new RealVector(random.Random(length));
    } while ((u1 <= 0.0).Any());
    u2 = new RealVector(random.Random(length));

    var mag = std * Sqrt(-2.0 * Log(u1));
    //var z0 = mag * Cos(2.0 * Math.PI * u2) + mean;
    var z1 = mag * Sin(2.0 * Math.PI * u2) + mean;
    
    return z1;
  }

  public static RealVector CreateUniform(int length, RealVector low, RealVector high, IRandomNumberGenerator random) {
    if (!AreCompatible(length, low, high)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    
    RealVector value = new RealVector(random.Random(length));
    value = low + (high - low) * value;
    return value;
  }

  public static RealVector Sqrt(RealVector vector) {
    return new RealVector(vector.Select(Math.Sqrt));
  }
  
  public static RealVector Log(RealVector vector) {
    return new RealVector(vector.Select(v => Math.Log(v)));
  }

  public static RealVector Sin(RealVector vector) {
    return new RealVector(vector.Select(Math.Sin));
  }
  
  public static RealVector Clamp(RealVector input, RealVector? min, RealVector? max) {
    if (min is null && max is null) return input; // No clamping needed
    
    // Validate lengths
    if (min is not null && min.Count != 1 && min.Count != input.Count)
        throw new ArgumentException($"Min vector must be of length 1 or match input length ({input.Count})");
    
    if (max is not null && max.Count != 1 && max.Count != input.Count)
        throw new ArgumentException($"Max vector must be of length 1 or match input length ({input.Count})");
    
    double[] result = new double[input.Count];
    
    for (int i = 0; i < input.Count; i++) {
        double value = input[i];
        
        // Apply lower bound if present
        if (min is not null) {
            double minValue = min.Count == 1 ? min[0] : min[i];
            value = Math.Max(value, minValue);
        }
        
        // Apply upper bound if present
        if (max is not null) {
            double maxValue = max.Count == 1 ? max[0] : max[i];
            value = Math.Min(value, maxValue);
        }
        
        result[i] = value;
    }
    
    return new RealVector(result);
  }
  
  public static BoolVector operator >(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue > bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator <(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue < bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator >=(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue >= bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator <=(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue <= bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static bool operator ==(RealVector a, RealVector b) => a.Equals(b);
  public static bool operator !=(RealVector a, RealVector b) => !a.Equals(b);
  
  public override bool Equals(object? obj) {
    if (obj is RealVector other)
      return elements.SequenceEqual(other.elements);
    return false;
  }
  
  public override int GetHashCode() {
    return HashCode.Combine(elements);
  }
  
  public override string ToString() {
    return $"[{string.Join(", ", elements)}]";
  }
}

public class GaussianMutator : MutatorBase<RealVector> {
  public double MutationRate { get; }
  public double MutationStrength { get; }
  public RealVectorEncodingParameter Encoding { get; }
  public IRandomSource RandomSource { get; }

  public GaussianMutator(double mutationRate, double mutationStrength, RealVectorEncodingParameter encoding, IRandomSource randomSource) {
    MutationRate = mutationRate;
    MutationStrength = mutationStrength;
    Encoding = encoding;
    RandomSource = randomSource;
  }

  public override RealVector Mutate(RealVector solution) {
    var rng = RandomSource.CreateRandomNumberGenerator();
    double[] newElements = solution.ToArray();
    for (int i = 0; i < newElements.Length; i++) {
      if (rng.Random() < MutationRate) {
        newElements[i] += MutationStrength * (rng.Random() - 0.5);
      }
    }
    return RealVector.Clamp(new RealVector(newElements), Encoding.Minimum, Encoding.Maximum);
  }

  public class Factory : IEncodingParameterDependentOperatorFactory<GaussianMutator, RealVectorEncodingParameter> {
    private readonly double? rate;
    private readonly double? strength;
    
    
    public Factory(double? rate = null, double? strength = null) {
      this.rate = rate;
      this.strength = strength;
    }
    
    public GaussianMutator Create(RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
      return new GaussianMutator(rate ?? 1.0, strength ?? 1.0, encodingParameter, randomSource);
    }
  }
}


public class SinglePointCrossover : CrossoverBase<RealVector> {
  // public RealVectorEncoding Encoding { get; }
  public IRandomSource RandomSource { get; }
  public SinglePointCrossover(/*RealVectorEncoding encoding,*/IRandomSource randomSource) {
  //   this.Encoding = encoding;
    this.RandomSource = randomSource;
  }
  
  public override RealVector Cross(RealVector parent1, RealVector parent2) {
    var rng = RandomSource.CreateRandomNumberGenerator();
    int crossoverPoint = rng.Integer(1, parent1.Count);
    double[] offspringValues = new double[parent1.Count];
    for (int i = 0; i < crossoverPoint; i++) {
      offspringValues[i] = parent1[i];
    }
    for (int i = crossoverPoint; i < parent2.Count; i++) {
      offspringValues[i] = parent2[i];
    }
    return new RealVector(offspringValues);
  }

  public class Factory : IEncodingParameterDependentOperatorFactory<SinglePointCrossover, RealVectorEncodingParameter> {
    public SinglePointCrossover Create(RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
      return new SinglePointCrossover(randomSource);
    }
  }
}

public class NormalDistributedCreator : CreatorBase<RealVector> {
  public RealVector Means { get; }
  public RealVector Sigmas { get; }
  public RealVectorEncodingParameter EncodingParameter { get; }
  public IRandomSource RandomSource { get; }

  //public const double DefaultMeans = 0.0;
  //public const double DefaultSigmas = 1.0;

  public NormalDistributedCreator(RealVector means, RealVector sigmas, RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
    if (!RealVector.AreCompatible(encodingParameter.Length, means, sigmas, encodingParameter.Minimum, encodingParameter.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    Means = means;
    Sigmas = sigmas;
    EncodingParameter = encodingParameter;
    RandomSource = randomSource;
  }

  public override RealVector Create() {
    var rng = RandomSource.CreateRandomNumberGenerator();
    RealVector value = RealVector.CreateNormal(EncodingParameter.Length, Means, Sigmas, rng);
    // Clamp value to min/max bounds
    value = RealVector.Clamp(value, EncodingParameter.Minimum, EncodingParameter.Maximum);
    return value;
  }

  public class Factory : IEncodingParameterDependentOperatorFactory<NormalDistributedCreator, RealVectorEncodingParameter> {
    private readonly RealVector? means;
    private readonly RealVector? standardDeviations;
    
    public Factory(RealVector? means = null, RealVector? standardDeviations = null) {
      this.means = means;
      this.standardDeviations = standardDeviations;
    }
    
    public NormalDistributedCreator Create(RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
      return new NormalDistributedCreator(means ?? 0.0, standardDeviations ?? 1.0, encodingParameter, randomSource);
    }
  }
}

public class UniformDistributedCreator : CreatorBase<RealVector> {
  public RealVector? Minimum { get; }
  public RealVector? Maximum { get; }
  public RealVectorEncodingParameter EncodingParameter { get; }
  public IRandomSource RandomSource { get; }

  public UniformDistributedCreator(RealVector? minimum, RealVector? maximum, RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
    if (minimum is not null && (minimum < encodingParameter.Minimum).Any()) throw new ArgumentException("Minimum values must be greater or equal to encoding minimum values");
    if (maximum is not null && (maximum > encodingParameter.Maximum).Any()) throw new ArgumentException("Maximum values must be less or equal to encoding maximum values");
    if (!RealVector.AreCompatible(encodingParameter.Length, minimum ?? encodingParameter.Minimum, maximum ?? encodingParameter.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    
    Minimum = minimum;
    Maximum = maximum;
    EncodingParameter = encodingParameter;
    RandomSource = randomSource;
  }

  public override RealVector Create() {
    var rng = RandomSource.CreateRandomNumberGenerator();
    return RealVector.CreateUniform(EncodingParameter.Length, Minimum ?? EncodingParameter.Minimum, Maximum ?? EncodingParameter.Maximum, rng);
  }

  public class Factory : IEncodingParameterDependentOperatorFactory<UniformDistributedCreator, RealVectorEncodingParameter> {
    private readonly RealVector? minimum;
    private readonly RealVector? maximum;
    
    public Factory(double[]? minimum = null, double[]? maximum = null) {
      this.minimum = minimum != null ? new RealVector(minimum) : null;
      this.maximum = maximum != null ? new RealVector(maximum) : null;
    }
    
    public UniformDistributedCreator Create(RealVectorEncodingParameter encodingParameter, IRandomSource randomSource) {
    return new UniformDistributedCreator(minimum, maximum, encodingParameter, randomSource);
    }
  }
}

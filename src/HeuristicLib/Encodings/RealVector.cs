using HEAL.HeuristicLib.Operators;
using HEAL.HeuristicLib.Random;

namespace HEAL.HeuristicLib.Encodings;

public record class RealVectorEncoding : SearchSpace<RealVector> {
  public int Length { get; }
  public RealVector Minimum { get; }
  public RealVector Maximum { get; }
  //public IRepairer<RealVector> OutOfBoundsRepairer { get; }

  public RealVectorEncoding(int length, RealVector minimum, RealVector maximum/*, OutOfBoundsStrategy outOfBoundsRepairer = OutOfBoundsStrategy.Clamp*/) {
    if (!RealVector.AreCompatible(length, minimum, maximum)) throw new ArgumentException("Minimum and Maximum vector must be of length 1 or match the encoding length");
    Length = length;
    Minimum = minimum;
    Maximum = maximum;
  //  OutOfBounds = outOfBounds;
  }
  
  public override bool IsValid(RealVector genotype) {
    return genotype.Count == Length
           && (genotype >= Minimum).All()
           && (genotype <= Maximum).All();
  }

  // This is generated by the record anyway
  // #pragma warning disable S125
  // public override bool Equals(IEncoding<RealVector>? other) {
  //   if (other is null) return false;
  //   if (ReferenceEquals(this, other)) return true;
  //   if (other is RealVectorEncoding otherRealVectorEncoding) {
  //     return Length == otherRealVectorEncoding.Length 
  //            && Minimum == otherRealVectorEncoding.Minimum
  //            && Maximum == otherRealVectorEncoding.Maximum;
  //   }
  //   return false;
  // }
  // #pragma warning restore S125
}

// public enum OutOfBoundsStrategy {
//   Clamp,
//   Reflect,
//   Randomize,
//   Exception
// }
//
// public interface IRepairer<TGenotype> {
//   TGenotype Repair(TGenotype genotype);
// }

// public abstract class RealVectorRepairer : IRepairer<RealVector> {
//   public static ClampRepairer Clamp(RealVectorEncoding parameter) => new ClampRepairer(parameter);
//   
//   protected RealVectorEncoding Parameter { get; }
//   protected RealVectorRepairer(RealVectorEncoding parameter) {
//     Parameter = parameter;
//   }
//   public abstract RealVector Repair(RealVector genotype);
// }
// public class ClampRepairer : RealVectorRepairer {
//   public ClampRepairer(RealVectorEncoding parameter) : base(parameter) { }
//   public override RealVector Repair(RealVector genotype) => RealVector.Clamp(genotype, Parameter.Minimum, Parameter.Maximum);
// }
//
// public class RealVectorEncoding<TPhenotype>
//   : Encoding<RealVector, TPhenotype>,
//     ICreatorProvidingEncoding<RealVector, RealVectorEncoding>, ICrossoverProvidingEncoding<RealVector, RealVectorEncoding>, IMutatorProvidingEncoding<RealVector, RealVectorEncoding> {
//   
//   public required ICreator<RealVector, RealVectorEncoding> Creator { get; init; }
//   public required ICrossover<RealVector, RealVectorEncoding> Crossover { get; init; }
//   public required IMutator<RealVector, RealVectorEncoding> Mutator { get; init; }
//   
//   public RealVectorEncoding(IDecoder<RealVector, TPhenotype> decoder) 
//     : base(decoder) { }
// }

// public class RealVectorEncoding : RealVectorEncoding<RealVector> { // Genotype = Phenotype
//   public RealVectorEncoding(RealVectorEncoding parameter) : base(parameter, Operators.Decoder.Identity<RealVector>()) { }
// }

[System.Diagnostics.CodeAnalysis.SuppressMessage("Blocker Code Smell", "S3877:Exceptions should not be thrown from unexpected methods")]
public class RealVector : IReadOnlyList<double>, IEquatable<RealVector> {
  private readonly double[] elements;

  public RealVector(params IEnumerable<double> elements) {
    this.elements = elements.ToArray();
  }

  // public RealVector(double value) {
  //   elements = [value];
  // }

  public static implicit operator RealVector(double value) => new RealVector(value);
  
  public static implicit operator RealVector(double[] values) => new RealVector(values);
  //public static implicit operator RealVector?(double[]? values) => values is not null ? new RealVector(values) : null;

  public double this[int index] => elements[index];

  public double this[Index index] => elements[index];

  public IEnumerator<double> GetEnumerator() => ((IEnumerable<double>)elements).GetEnumerator();

  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => elements.GetEnumerator();

  public static RealVector Add(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x + a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x + b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] + b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Subtract(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x - a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x - b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] - b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Multiply(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x * a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x * b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] * b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector Divide(RealVector a, RealVector b) {
    if (a.elements.Length != b.elements.Length) {
      if (a.elements.Length == 1) {
        return new RealVector(b.elements.Select(x => x / a.elements[0]));
      }
      if (b.elements.Length == 1) {
        return new RealVector(a.elements.Select(x => x / b.elements[0]));
      }
      throw new ArgumentException("Vectors must be of the same length or one of length one");
    }
    var result = new double[a.elements.Length];
    for (int i = 0; i < a.elements.Length; i++) {
      result[i] = a.elements[i] / b.elements[i];
    }
    return new RealVector(result);
  }

  public static RealVector operator +(RealVector a, RealVector b) => Add(a, b);
  public static RealVector operator -(RealVector a, RealVector b) => Subtract(a, b);
  public static RealVector operator *(RealVector a, RealVector b) => Multiply(a, b);
  public static RealVector operator /(RealVector a, RealVector b) => Divide(a, b);

  public int Count => elements.Length;

  public bool Contains(double value) => elements.Contains(value);

  public bool Equals(RealVector? other) {
    if (other is null) return false;
    return ReferenceEquals(this, other) || elements.SequenceEqual(other.elements);
  }
  
  public override int GetHashCode() {
    var hash = new HashCode();
    foreach (var element in elements) {
      hash.Add(element);
    }
    return hash.ToHashCode();
  }

  public static bool AreCompatible(RealVector a, RealVector b) {
    return a.Count == b.Count || a.Count == 1 || b.Count == 1;
  }
  public static bool AreCompatible(RealVector vector, params IEnumerable<RealVector> others) {
    return others.All(v => AreCompatible(vector, v));
  }
  public static bool AreCompatible(int length, params IEnumerable<RealVector> vectors) {
    return vectors.All(v => v.Count == length || v.Count == 1);
  }
  
  public static int BroadcastLength(RealVector a, RealVector b) {
    return Math.Max(a.Count, b.Count);
  }
  public static int BroadcastLength(RealVector vector, IEnumerable<RealVector> others) {
    if (!AreCompatible(vector, others)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    return others.Max(v => v.Count);
  }
  
  public static RealVector CreateNormal(int length, RealVector mean, RealVector std, IRandomNumberGenerator random) {
    if (!AreCompatible(length, mean, std)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    
    // Box-Muller transform to generate normal distributed random values
    RealVector u1, u2;
    do {
      u1 = new RealVector(random.Random(length));
    } while ((u1 <= 0.0).Any());
    u2 = new RealVector(random.Random(length));

    var mag = std * Sqrt(-2.0 * Log(u1));
    //var z0 = mag * Cos(2.0 * Math.PI * u2) + mean;
    var z1 = mag * Sin(2.0 * Math.PI * u2) + mean;
    
    return z1;
  }

  public static RealVector CreateUniform(int length, RealVector low, RealVector high, IRandomNumberGenerator random) {
    if (!AreCompatible(length, low, high)) throw new ArgumentException("Vectors must be compatible for broadcasting");
    
    RealVector value = new RealVector(random.Random(length));
    value = low + (high - low) * value;
    return value;
  }

  public static RealVector Sqrt(RealVector vector) {
    return new RealVector(vector.Select(Math.Sqrt));
  }
  
  public static RealVector Log(RealVector vector) {
    return new RealVector(vector.Select(v => Math.Log(v)));
  }

  public static RealVector Sin(RealVector vector) {
    return new RealVector(vector.Select(Math.Sin));
  }
  
  public static RealVector Clamp(RealVector input, RealVector? min, RealVector? max) {
    if (min is null && max is null) return input; // No clamping needed
    
    // Validate lengths
    if (min is not null && min.Count != 1 && min.Count != input.Count)
        throw new ArgumentException($"Min vector must be of length 1 or match input length ({input.Count})");
    
    if (max is not null && max.Count != 1 && max.Count != input.Count)
        throw new ArgumentException($"Max vector must be of length 1 or match input length ({input.Count})");
    
    double[] result = new double[input.Count];
    
    for (int i = 0; i < input.Count; i++) {
        double value = input[i];
        
        // Apply lower bound if present
        if (min is not null) {
            double minValue = min.Count == 1 ? min[0] : min[i];
            value = Math.Max(value, minValue);
        }
        
        // Apply upper bound if present
        if (max is not null) {
            double maxValue = max.Count == 1 ? max[0] : max[i];
            value = Math.Min(value, maxValue);
        }
        
        result[i] = value;
    }
    
    return new RealVector(result);
  }
  
  public static BoolVector operator >(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue > bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator <(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue < bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator >=(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue >= bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static BoolVector operator <=(RealVector a, RealVector b) {
    if (!AreCompatible(a, b)) throw new ArgumentException("Vectors must be compatible for comparison");
    
    int length = BroadcastLength(a, b);
    bool[] result = new bool[length];
    
    for (int i = 0; i < length; i++) {
      double aValue = a.Count == 1 ? a[0] : a[i];
      double bValue = b.Count == 1 ? b[0] : b[i];
      result[i] = aValue <= bValue;
    }
    
    return new BoolVector(result);
  }
  
  public static bool operator ==(RealVector a, RealVector b) => a.Equals(b);
  public static bool operator !=(RealVector a, RealVector b) => !a.Equals(b);

  public static RealVector Repeat(double value, int count) {
    return new RealVector(Enumerable.Repeat(value, count));
  }
  
  // public override bool Equals(object? obj) {
  //   if (obj is RealVector other)
  //     return elements.SequenceEqual(other.elements);
  //   return false;
  // }
  
  
  public override string ToString() {
    return $"[{string.Join(", ", elements)}]";
  }
}


public record class AlphaBetaBlendCrossover : Crossover<RealVector, RealVectorEncoding> {
  public double Alpha { get; }
  public double Beta { get; }
  
  public AlphaBetaBlendCrossover(double alpha = 0.7, double beta = 0.3) {
    Alpha = alpha;
    Beta = beta;
  }

  public override AlphaBetaBlendCrossoverInstance CreateInstance() => new AlphaBetaBlendCrossoverInstance(this);
}

public class AlphaBetaBlendCrossoverInstance : CrossoverInstance<RealVector, RealVectorEncoding, AlphaBetaBlendCrossover> {
  public AlphaBetaBlendCrossoverInstance(AlphaBetaBlendCrossover parameters) : base(parameters) { }
  public override RealVector Cross(RealVector parent1, RealVector parent2, RealVectorEncoding encoding, IRandomNumberGenerator random) {
    return Parameters.Alpha * parent1 + Parameters.Beta * parent2;
  }
}


public record class GaussianMutator : Mutator<RealVector, RealVectorEncoding> {
  public double MutationRate { get; }
  public double MutationStrength { get; }

  public GaussianMutator(double mutationRate, double mutationStrength) {
    MutationRate = mutationRate;
    MutationStrength = mutationStrength;
  }

  public override GaussianMutatorInstance CreateInstance() => new GaussianMutatorInstance(this);
}

public class GaussianMutatorInstance : MutatorInstance<RealVector, RealVectorEncoding, GaussianMutator> {
  public GaussianMutatorInstance(GaussianMutator parameters) : base(parameters) { }
  public override RealVector Mutate(RealVector solution, RealVectorEncoding encoding, IRandomNumberGenerator random) {
    double[] newElements = solution.ToArray();
    for (int i = 0; i < newElements.Length; i++) {
      if (random.Random() < Parameters.MutationRate) {
        newElements[i] += Parameters.MutationStrength * (random.Random() - 0.5);
      }
    }
    return RealVector.Clamp(new RealVector(newElements), encoding.Minimum, encoding.Maximum);
  }
}


public record class SinglePointCrossover : Crossover<RealVector, RealVectorEncoding> {
  public override SinglePointCrossoverInstance CreateInstance() => new SinglePointCrossoverInstance(this);
}

public class SinglePointCrossoverInstance : CrossoverInstance<RealVector, RealVectorEncoding, SinglePointCrossover> {
  public SinglePointCrossoverInstance(SinglePointCrossover parameters) : base(parameters) { }
  public override RealVector Cross(RealVector parent1, RealVector parent2, RealVectorEncoding encoding, IRandomNumberGenerator random) {
    int crossoverPoint = random.Integer(1, parent1.Count);
    double[] offspringValues = new double[parent1.Count];
    for (int i = 0; i < crossoverPoint; i++) {
      offspringValues[i] = parent1[i];
    }
    for (int i = crossoverPoint; i < parent2.Count; i++) {
      offspringValues[i] = parent2[i];
    }
    return RealVector.Clamp(new RealVector(offspringValues), encoding.Minimum, encoding.Maximum);
  }
}


public record class NormalDistributedCreator : Creator<RealVector, RealVectorEncoding> {
  public RealVector Means { get; }
  public RealVector Sigmas { get; }

  //public const double DefaultMeans = 0.0;
  //public const double DefaultSigmas = 1.0;

  public NormalDistributedCreator(RealVector means, RealVector sigmas) {
    //if (!RealVector.AreCompatible(encoding.Length, means, sigmas, encoding.Minimum, encoding.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    Means = means;
    Sigmas = sigmas;
  }
  
  public override NormalDistributedCreatorInstance CreateInstance() => new NormalDistributedCreatorInstance(this);
}

public class NormalDistributedCreatorInstance : CreatorInstance<RealVector, RealVectorEncoding, NormalDistributedCreator> {
  public NormalDistributedCreatorInstance(NormalDistributedCreator parameters) : base(parameters) { }
  public override RealVector Create(RealVectorEncoding encoding, IRandomNumberGenerator random) {
    if (!RealVector.AreCompatible(encoding.Length, Parameters.Means, Parameters.Sigmas, encoding.Minimum, encoding.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    RealVector value = RealVector.CreateNormal(encoding.Length, Parameters.Means, Parameters.Sigmas, random);
    // Clamp value to min/max bounds
    value = RealVector.Clamp(value, encoding.Minimum, encoding.Maximum);
    return value;
  }
}


public record class UniformDistributedCreator : Creator<RealVector, RealVectorEncoding> {
  public RealVector? Minimum { get; }
  public RealVector? Maximum { get; }

  public UniformDistributedCreator(RealVector? minimum = null, RealVector? maximum = null) {
    Minimum = minimum;
    Maximum = maximum;
  }
  
  public override UniformDistributedCreatorInstance CreateInstance() => new UniformDistributedCreatorInstance(this);
}

public class UniformDistributedCreatorInstance : CreatorInstance<RealVector, RealVectorEncoding, UniformDistributedCreator> {
  public UniformDistributedCreatorInstance(UniformDistributedCreator parameters) : base(parameters) { }
  public override RealVector Create(RealVectorEncoding encoding, IRandomNumberGenerator random) {
    if (Parameters.Minimum is not null && (Parameters.Minimum < encoding.Minimum).Any()) throw new ArgumentException("Minimum values must be greater or equal to encoding minimum values");
    if (Parameters.Maximum is not null && (Parameters.Maximum > encoding.Maximum).Any()) throw new ArgumentException("Maximum values must be less or equal to encoding maximum values");
    if (!RealVector.AreCompatible(encoding.Length, Parameters.Minimum ?? encoding.Minimum, Parameters.Maximum ?? encoding.Maximum)) throw new ArgumentException("Vectors must have compatible lengths");
    return RealVector.CreateUniform(encoding.Length, Parameters.Minimum ?? encoding.Minimum, Parameters.Maximum ?? encoding.Maximum, random);
  }
}

// // ToDo: move to different file
// public static class GeneticAlgorithmBuilderRealVectorEncodingExtensions {
//   // For type inference
//   public static GeneticAlgorithmBuilder<RealVector, RealVectorEncoding> UsingEncoding(this GeneticAlgorithmBuilder<RealVector> builder, RealVectorEncoding encoding) {
//     return builder.UsingEncoding<RealVector, RealVectorEncoding, RealVectorEncoding>(encoding);
//   }
// }

using HEAL.HeuristicLib.Genotypes.Vectors;
using HEAL.HeuristicLib.Optimization;

namespace HEAL.HeuristicLib.SearchSpaces.Vectors;

public record RealVectorSearchSpace : SearchSpace<RealVector>, ISubencodingComparable<RealVectorSearchSpace>
{
  //public IRepairer<RealVector> OutOfBoundsRepairer { get; }

  public RealVectorSearchSpace(int length, RealVector minimum, RealVector maximum/*, OutOfBoundsStrategy outOfBoundsRepairer = OutOfBoundsStrategy.Clamp*/)
  {
    if (!RealVector.AreCompatible(length, minimum, maximum)) {
      throw new ArgumentException("Minimum and Maximum vector must be of length 1 or match the searchSpace length");
    }
    Length = length;
    Minimum = minimum;
    Maximum = maximum;
    //  OutOfBounds = outOfBounds;
  }
  public int Length { get; }
  public RealVector Minimum { get; }
  public RealVector Maximum { get; }

  public bool IsSubspaceOf(RealVectorSearchSpace other)
  {
    return other.Length == Length
           && (other.Minimum >= Minimum).All()
           && (other.Maximum <= Maximum).All();
  }

  public override bool Contains(RealVector genotype)
  {
    return genotype.Count == Length
           && (genotype >= Minimum).All()
           && (genotype <= Maximum).All();
  }

  // This is generated by the record anyway
  // #pragma warning disable S125
  // public override bool Equals(ISearchSpace<RealVector>? other) {
  //   if (other is null) return false;
  //   if (ReferenceEquals(this, other)) return true;
  //   if (other is RealVectorSearchSpace otherRealVectorSearchSpace) {
  //     return Length == otherRealVectorSearchSpace.Length 
  //            && Minimum == otherRealVectorSearchSpace.Minimum
  //            && Maximum == otherRealVectorSearchSpace.Maximum;
  //   }
  //   return false;
  // }
  // #pragma warning restore S125
}

// public enum OutOfBoundsStrategy {
//   Clamp,
//   Reflect,
//   Randomize,
//   Exception
// }
//
// public interface IRepairer<TGenotype> {
//   TGenotype Repair(TGenotype genotype);
// }

// public abstract class RealVectorRepairer : IRepairer<RealVector> {
//   public static ClampRepairer Clamp(RealVectorSearchSpace parameter) => new ClampRepairer(parameter);
//   
//   protected RealVectorSearchSpace Parameter { get; }
//   protected RealVectorRepairer(RealVectorSearchSpace parameter) {
//     Parameter = parameter;
//   }
//   public abstract RealVector Repair(RealVector genotype);
// }
// public class ClampRepairer : RealVectorRepairer {
//   public ClampRepairer(RealVectorSearchSpace parameter) : base(parameter) { }
//   public override RealVector Repair(RealVector genotype) => RealVector.Clamp(genotype, Parameter.Minimum, Parameter.Maximum);
// }
//
// public class RealVectorSearchSpace<TPhenotype>
//   : SearchSpace<RealVector, TPhenotype>,
//     ICreatorProvidingSearchSpace<RealVector, RealVectorSearchSpace>, ICrossoverProvidingSearchSpace<RealVector, RealVectorSearchSpace>, IMutatorProvidingSearchSpace<RealVector, RealVectorSearchSpace> {
//   
//   public required ICreator<RealVector, RealVectorSearchSpace> Creator { get; init; }
//   public required ICrossover<RealVector, RealVectorSearchSpace> Crossover { get; init; }
//   public required IMutator<RealVector, RealVectorSearchSpace> Mutator { get; init; }
//   
//   public RealVectorSearchSpace(IDecoder<RealVector, TPhenotype> decoder) 
//     : base(decoder) { }
// }

// public class RealVectorSearchSpace : RealVectorSearchSpace<RealVector> { // Genotype = Phenotype
//   public RealVectorSearchSpace(RealVectorSearchSpace parameter) : base(parameter, Operators.Decoder.Identity<RealVector>()) { }
// }

// // ToDo: move to different file
// public static class GeneticAlgorithmBuilderRealVectorSearchSpaceExtensions {
//   // For type inference
//   public static GeneticAlgorithmBuilder<RealVector, RealVectorSearchSpace> UsingSearchSpace(this GeneticAlgorithmBuilder<RealVector> builder, RealVectorSearchSpace searchSpace) {
//     return builder.UsingSearchSpace<RealVector, RealVectorSearchSpace, RealVectorSearchSpace>(searchSpace);
//   }
// }
